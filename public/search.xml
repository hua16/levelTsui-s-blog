<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用事件响应链处理事件]]></title>
    <url>%2F2018%2F07%2F03%2F%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%93%BE%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述Apps receive and handle events using responder objects. A responder object is any instance of the UIResponder class, and common subclasses include UIView, UIViewController, and UIApplication. Responders receive the raw event data and must either handle the event or forward it to another responder object. When your app receives an event, UIKit automatically directs that event to the most appropriate responder object, known as the first responder.Unhandled events are passed from responder to responder in the active responder chain, which is the dynamic configuration of your app’s responder objects. Figure 1 shows the responders in an app whose interface contains a label, a text field, a button, and two background views. The diagram also shows how events move from one responder to the next, following the responder chain.If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object, followed by the root view of the window. From the root view, the responder chain diverts to the owning view controller before directing the event to the window. If the window cannot handle the event, UIKit delivers the event to the UIApplication object, and possibly to the app delegate if that object is an instance of UIResponder and not already part of the responder chain.基于ResponderChain实现对象交互我们可以借用responder chain实现了一个自己的事件传递链。1234567891011121314151617181920//UIResponder的分类//.h文件#import &lt;UIKit/UIKit.h&gt;@interface UIResponder (Router)- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo;@end//.m文件#import "UIResponder+Router.h"@implementation UIResponder (Router)- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; [[self nextResponder] routerEventWithName:eventName userInfo:userInfo];&#125;@end123456789101112131415161718192021222324252627282930313233343536//NSObject//.h文件#import &lt;Foundation/Foundation.h&gt;@interface NSObject (Invocation)- (NSInvocation *)createInvocationWithSelector:(SEL)aSelector;@end//.m文件#import "NSObject+Invocation.h"@implementation NSObject (Invocation)- (NSInvocation *)createInvocationWithSelector:(SEL)aSelector &#123; //1、创建签名对象 NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector]; //2、判断传入的方法是否存在 if (signature==nil) &#123; //传入的方法不存在 就抛异常 NSString*info = [NSString stringWithFormat:@"-[%@ %@]:unrecognized selector sent to instance",[self class],NSStringFromSelector(aSelector)]; @throw [[NSException alloc] initWithName:@"方法没有" reason:info userInfo:nil]; return nil; &#125; //3、、创建NSInvocation对象 NSInvocation*invocation = [NSInvocation invocationWithMethodSignature:signature]; //4、保存方法所属的对象 invocation.target = self; invocation.selector = aSelector; return invocation;&#125;@end在需要响应事件的类中重载routerEventWithName::方法123- (void)routerEventWithName:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; [self.eventProxy handleEvent:eventName userInfo:userInfo];&#125;使用EventProxy类来专门处理对应的事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//EventProxy.h#import &lt;Foundation/Foundation.h&gt;@interface EventProxy : NSObject- (void)handleEvent:(NSString *)eventName userInfo:(NSDictionary *)userInfo;@end//EventProxy.m#import "EventProxy.h"#import "ResponderChainDefine.h"#import "UIResponder+Router.h"#import "NSObject+Invocation.h"@interface EventProxy ()@property (nonatomic, strong) NSDictionary *eventStrategy;@end@implementation EventProxy- (void)handleEvent:(NSString *)eventName userInfo:(NSDictionary *)userInfo &#123; NSInvocation *invocation = self.eventStrategy[eventName]; [invocation setArgument:&amp;userInfo atIndex:2]; [invocation invoke];&#125;- (void)cellLeftButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 左边按钮被点击啦！",indexPath.section, indexPath.row);&#125;- (void)cellMiddleButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 中间按钮被点击啦！",indexPath.section, indexPath.row);&#125;- (void)cellRightButtonClick:(NSDictionary *)userInfo &#123; NSIndexPath *indexPath = userInfo[@"indexPath"]; NSLog(@"indexPath:section:%ld, row:%ld 右边按钮被点击啦！",indexPath.section, indexPath.row);&#125;#pragma mark - getter &amp; setter- (NSDictionary &lt;NSString *, NSInvocation *&gt;*)eventStrategy &#123; if (!_eventStrategy) &#123; _eventStrategy = @&#123; kTableViewCellEventTappedLeftButton:[self createInvocationWithSelector:@selector(cellLeftButtonClick:)], kTableViewCellEventTappedMiddleButton:[self createInvocationWithSelector:@selector(cellMiddleButtonClick:)], kTableViewCellEventTappedRightButton:[self createInvocationWithSelector:@selector(cellRightButtonClick:)] &#125;; &#125; return _eventStrategy;&#125;@end在TableViewCell的事件中，调用routerEventWithName:userInfo:方法，就会调用到EventProxy类中的方法。123456789101112131415@implementation TableViewCell- (IBAction)leftButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedLeftButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;- (IBAction)middelButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedMiddleButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;- (IBAction)rightButtonClick:(UIButton *)sender &#123; [self routerEventWithName:kTableViewCellEventTappedRightButton userInfo:@&#123;@"indexPath":self.indexPath&#125;];&#125;@end总结使用这种基于Responder Chain的方式来传递事件，在复杂UI层级的页面中，可以避免无谓的delegate声明。事件处理的逻辑得到归拢，在这个方法里面下断点就能够管理所有的事件处理。参考文章Using Responders and the Responder Chain to Handle Events一种基于ResponderChain的对象交互方式responderChainDemo]]></content>
      <categories>
        <category>iOS 技巧</category>
      </categories>
      <tags>
        <tag>事件响应链  responder chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS长按移动Table View Cells]]></title>
    <url>%2F2018%2F01%2F19%2FiOS%E9%95%BF%E6%8C%89%E7%A7%BB%E5%8A%A8Table%20View%20Cells%2F</url>
    <content type="text"><![CDATA[前言最近参与了事务流程工具化组件的开发，其中有一个模块需要通过长按移动Table View Cells，来达到调整任务的需求，再次记录下开发过程中的实现思路。完成后的效果如下图所示：实现思路添加手势首先给 collection view 添加一个 UILongGestureRecognizer,在项目中一般使用懒加载的方式来对对象进行初始化：12345678910111213141516171819- (UICollectionView *)collectionView &#123; if (!_collectionView) &#123; _collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.flowLayout]; _collectionView.backgroundColor = [UIColor whiteColor]; _collectionView.dataSource = self; _collectionView.delegate = self; [_collectionView registerClass:[TLCMainCollectionViewCell class] forCellWithReuseIdentifier:[TLCMainCollectionViewCell identifier]]; _collectionView.showsHorizontalScrollIndicator = NO; _collectionView.showsVerticalScrollIndicator = NO; _collectionView.bounces = YES; _collectionView.decelerationRate = 0; [_collectionView addGestureRecognizer:self.longPress]; &#125; return _collectionView;&#125;123456- (UILongPressGestureRecognizer *)longPress &#123; if (!_longPress) &#123; _longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressGestureRecognized:)]; &#125; return _longPress;&#125;在用户长按后，触犯长按事件，先获取到当前手势所在的collection view位置，再做后续的处理。12345678910111213141516171819202122232425- (void)longPressGestureRecognized:(UILongPressGestureRecognizer *)sender &#123; CGPoint location = [sender locationInView:sender.view]; UIGestureRecognizerState state = sender.state; switch (state) &#123; case UIGestureRecognizerStateBegan: &#123; [self handleLongPressStateBeganWithLocation:location]; &#125; break; case UIGestureRecognizerStateChanged: &#123; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; [self longGestureEndedOrCancelledWithLocation:location]; &#125; break; default: break; &#125;&#125;长按手势状态为开始主要处理两个方面的事务，一为获取当前长按手势所对应的Table View Cell的镜像，将其添加到 Collection View上。二为一些初始状态的设置，后续在移动后网络请求出错及判断当前手势所处的Table View和上一次是否一致需要使用到。最后调用startPageEdgeScroll开启定时器。123456789101112131415161718192021222324252627282930- (void)handleLongPressStateBeganWithLocation:(CGPoint)location &#123; TLCMainCollectionViewCell *selectedCollectionViewCell = [self currentTouchedCollectionCellWithLocation:location]; NSIndexPath *touchIndexPath = [self longGestureBeganIndexPathForRowAtPoint:location atTableView:selectedCollectionViewCell.tableView]; if (!selectedCollectionViewCell || !touchIndexPath) &#123; return ; &#125; self.selectedCollectionViewCellRow = [self.collectionView indexPathForCell:selectedCollectionViewCell].row; // 已完成的任务，不支持排序 TLPlanItem *selectedItem = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:touchIndexPath.section]; if (!selectedItem || selectedItem.finish) &#123; return; &#125; selectedItem.isHidden = YES; self.snapshotView = [self snapshotViewWithTableView:selectedCollectionViewCell.tableView atIndexPath:touchIndexPath]; [self.collectionView addSubview:self.snapshotView]; self.selectedIndexPath = touchIndexPath; self.originalSelectedIndexPathSection = touchIndexPath.section; self.originalCollectionViewCellRow = self.selectedCollectionViewCellRow; self.previousPoint = CGPointZero; [self startPageEdgeScroll];&#125;长按手势状态为改变在longPressGestureRecognized方法中，可以发现，长按手势状态改变时，并未做任何的操作，主要原因是如果在此做Table View Cells的移动操作，如果数据超过一屏幕，无法自动将未在屏幕上的数据滚动显示出来。所以在长按手势状态为开始时，如果触摸点在Table View Cell上，开启定时器，来处理长按手势状态为改变时的情况。1234- (void)startPageEdgeScroll &#123; self.edgeScrollTimer = [CADisplayLink displayLinkWithTarget:self selector:@selector(pageEdgeScrollEvent)]; [self.edgeScrollTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;在定时器触发的事件中，处理两个方面的事情，移动cell和滚动ScrollView。12345678910111213- (void)pageEdgeScrollEvent &#123; [self longGestureChanged:self.longPress]; CGFloat snapshotViewCenterOffsetX = [self touchSnapshotViewCenterOffsetX]; if (fabs(snapshotViewCenterOffsetX) &gt; (TLCMainViewControllerFlowLayoutWidthOffset-20)) &#123; //横向滚动 [self handleScrollViewHorizontalScroll:self.collectionView viewCenterOffsetX:snapshotViewCenterOffsetX]; &#125; else &#123; //垂直滚动 [self handleScrollViewVerticalScroll:[self selectedCollectionViewCellTableView]]; &#125;&#125;在长按手势触摸点位置改变时，处理对应cell的移除和插入动作。横向滚动和垂直滚动主要是根据不同情况设置对应的Table View 和 Collection View的内容偏移量。可以在文末的链接中查看源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)longGestureChanged:(UILongPressGestureRecognizer *)sender &#123; CGPoint currentPoint = [sender locationInView:sender.view]; TLCMainCollectionViewCell *currentCollectionViewCell = [self currentTouchedCollectionCellWithLocation:currentPoint]; if (!currentCollectionViewCell) &#123; currentCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; &#125; TLCMainCollectionViewCell *lasetSelectedCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; //判断targetTableView是否改变 BOOL isTargetTableViewChanged = NO; if (self.selectedCollectionViewCellRow != currentCollectionViewCell.indexPath.row) &#123; isTargetTableViewChanged = YES; self.selectedCollectionViewCellRow = currentCollectionViewCell.indexPath.row; &#125; //获取到需要移动到的目标indexpath NSIndexPath *targetIndexPath = [self longGestureChangeIndexPathForRowAtPoint:currentPoint collectionViewCell:currentCollectionViewCell]; NSIndexPath *lastSelectedIndexPath = self.selectedIndexPath; TLCMainCollectionViewCell *selectedCollectionViewCell = [self collectionViewCellAtRow:self.selectedCollectionViewCellRow]; //判断跟上一次长按手势所处的Table View是否相同，如果相同，移动cell， //如果不同，删除上一次所定义的cell，插入到当前位置 if (isTargetTableViewChanged) &#123; if ([[self selectedCollectionViewCellTableView] numberOfSections]&gt;targetIndexPath.section) &#123; [[self selectedCollectionViewCellTableView] scrollToRowAtIndexPath:targetIndexPath atScrollPosition:UITableViewScrollPositionNone animated:YES]; &#125; TLPlanItem *moveItem = [self.viewModel itemAtIndex:lasetSelectedCollectionViewCell.indexPath.row subItemIndex:lastSelectedIndexPath.section]; [self.viewModel removeObject:moveItem itemIndex:lasetSelectedCollectionViewCell.indexPath.row]; [self.viewModel insertItem:moveItem index:self.selectedCollectionViewCellRow subItemIndex:targetIndexPath.section]; [lasetSelectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:lasetSelectedCollectionViewCell.indexPath.row]]; [lasetSelectedCollectionViewCell.tableView deleteSections:[NSIndexSet indexSetWithIndex:lastSelectedIndexPath.section] withRowAnimation:UITableViewRowAnimationNone]; [selectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:self.selectedCollectionViewCellRow]]; [selectedCollectionViewCell.tableView insertSections:[NSIndexSet indexSetWithIndex:targetIndexPath.section] withRowAnimation:UITableViewRowAnimationNone]; &#125; else &#123; BOOL isSameSection = lastSelectedIndexPath.section == targetIndexPath.section; UITableViewCell *targetCell = [self tableView:[self selectedCollectionViewCellTableView] selectedCellAtSection:targetIndexPath.section]; if (isSameSection || !targetCell ) &#123; [self modifySnapshotViewFrameWithTouchPoint:currentPoint]; return; &#125; TLPlanItem *item = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:lastSelectedIndexPath.section]; [self.viewModel removeObject:item itemIndex:self.selectedCollectionViewCellRow]; [self.viewModel insertItem:item index:self.selectedCollectionViewCellRow subItemIndex:targetIndexPath.section]; [selectedCollectionViewCell updateCellWithData:[self planItemsAtIndex:self.selectedCollectionViewCellRow]]; [selectedCollectionViewCell.tableView moveSection:lastSelectedIndexPath.section toSection:targetIndexPath.section]; &#125; self.selectedIndexPath = targetIndexPath; //改变长按cell镜像的位置 [self modifySnapshotViewFrameWithTouchPoint:currentPoint];&#125;长按手势状态为取消或结束取消计时器，设置Collection View的偏移量，让其Collection View Cell位于屏幕的中心，发送网络请求，去调整任务的排序，同时将镜像视图隐藏，并将其所对应的Table View Cell显示出来。12345678910111213141516171819202122232425- (void)longGestureEndedOrCancelledWithLocation:(CGPoint)location &#123; [self stopEdgeScrollTimer]; CGPoint contentOffset = [self.flowLayout targetContentOffsetForProposedContentOffset:self.collectionView.contentOffset withScrollingVelocity:CGPointZero]; [self.collectionView setContentOffset:contentOffset animated:YES]; UITableViewCell *targetCell = [[self selectedCollectionViewCellTableView] cellForRowAtIndexPath:self.selectedIndexPath]; if ([self canAdjustPlanRanking]) &#123; [self adjustPlanRanking]; &#125; TLPlanItem *slectedItem = [self.viewModel itemAtIndex:self.selectedCollectionViewCellRow subItemIndex:self.selectedIndexPath.section]; [UIView animateWithDuration:0.25 animations:^&#123; self.snapshotView.transform = CGAffineTransformIdentity; self.snapshotView.frame = [self snapshotViewFrameWithCell:targetCell]; &#125; completion:^(BOOL finished) &#123; targetCell.hidden = NO; slectedItem.isHidden = NO; [self.snapshotView removeFromSuperview]; self.snapshotView = nil; &#125;];&#125;数据的处理在移动和插入Table View Cell时，需要将其所对应的数据做响应的改变，数据相关的操作均放在TLCMainViewModel对象中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118@interface TLCMainViewModel : NSObject /** 今日要做、下一步要做和以后要做 */@property (nonatomic, readonly, strong) NSArray &lt;NSString *&gt; *titleArray; /** 获取计划列表 @param completion TLTodoModel */- (void)obtainTotalPlanListWithTypeCompletion:(TLSDKCompletionBlk)completion;/** 添加计划 @param requestItem requestItem @param completion 完成回调 */- (void)addPlanWithReq:(TLPlanItemReq *)requestItem atIndexPath:(NSIndexPath *)indexPath completion:(TLSDKCompletionBlk)completion;/** 返回显示的collectionViewCell的个数 @return 数据的个数 */- (NSInteger)numberOfItems;/** 根据type获取对应的数据 @param index 位置 @return 此计划所对应的数据 */- (NSMutableArray&lt;TLPlanItem *&gt; *)planItemsAtIndex:(NSInteger)index;/** 删除某个计划 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param completion 完成回调 */- (void)deletePlanAtItemIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex completion:(dispatch_block_t)completion;/** 修改计划状态：完成与非完成 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param completion 完成回调 */- (void)modiflyPlanStateAtItemIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex completion:(TLSDKCompletionBlk)completion;/** 修改计划的title和重点标记状态 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 @param targetItem 目标对象 @param completion 完成回调 */- (void)modiflyItemAtIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex targetItem:(TLPlanItem *)targetItem completion:(dispatch_block_t)completion;/** 移除数据 @param item item @param itemIndex 单项数据在数组中的位置 */- (void)removeObject:(TLPlanItem *)item itemIndex:(NSInteger)itemIndex;/** 插入数据 @param item 插入的对象模型 @param itemIndex 单项数据在数组中的位置，如今日计划中的数据，itemIndex为0 @param subItemIndex 单项数据数组中所在的位置 */- (void)insertItem:(TLPlanItem *)item index:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex;/** 获取数据 @param itemIndex 一级index @param subItemIndex 二级index @return 数据模型 */- (TLPlanItem *)itemAtIndex:(NSInteger)itemIndex subItemIndex:(NSInteger)subItemIndex; /** 重置数据 */- (void)reset;/** 保存长按开始时的数据 */- (void)storePressBeginState;@end代码完善cell未居中显示问题2018年2月1号在iPhone系统版本为iOS8.x和iOS9.x时，会出现以后要做界面不会回弹的情况。如下图所示：经排查，是在UICollectionViewFlowLayout类中的1- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity方法计算得出的proposedContentOffset有偏差，修改后如下所示：1234567891011121314151617181920212223242526- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity &#123; CGFloat rawPageValue = self.collectionView.contentOffset.x / [self tlc_pageWidth]; CGFloat currentPage = (velocity.x &gt; 0.0) ? floor(rawPageValue) : ceil(rawPageValue); CGFloat nextPage = (velocity.x &gt; 0.0) ? ceil(rawPageValue) : floor(rawPageValue); BOOL pannedLessThanAPage = fabs(1 + currentPage - rawPageValue) &gt; 0.5; BOOL flicked = fabs(velocity.x) &gt; [self tlc_flickVelocity]; CGFloat actualPage = 0.0; if (pannedLessThanAPage &amp;&amp; flicked) &#123; proposedContentOffset.x = nextPage * [self tlc_pageWidth]; actualPage = nextPage; &#125; else &#123; proposedContentOffset.x = round(rawPageValue) * [self tlc_pageWidth]; actualPage = round(rawPageValue); &#125; if (lround(actualPage) &gt;= 1) &#123; proposedContentOffset.x -= 4.5; &#125; //下面为添加的代码 if (lround(actualPage) &gt;= 2) &#123; proposedContentOffset.x = self.collectionView.contentSize.width - TLCScreenWidth; &#125; return proposedContentOffset;&#125;在系统版本为iOS9.x时，输入框会上一段距离问题2018年2月12号在机型为iPhone SE，系统版本为iOS9.x时，新建计划时，新建窗口会上移一段，如下图所示：分析发现，应该是监听键盘高度变化时，输入框的高度计算在特定机型的特定版本上计算错误，将原有的计算frame的来布局的方式改为自动布局。监听键盘高度改变的代码修改后如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self addObserverForKeybord];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.view endEditing:YES]; [self removeobserverForKeybord];&#125;#pragma mark - keyboard observer- (void)addObserverForKeybord &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];&#125;- (void)removeobserverForKeybord &#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];&#125;- (void)keyboardWillShow:(NSNotification *)notification &#123; CGRect keyboardBounds; [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] getValue:&amp;keyboardBounds]; NSNumber *duration = [notification.userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey]; NSNumber *curve = [notification.userInfo objectForKey:UIKeyboardAnimationCurveUserInfoKey]; keyboardBounds = [self.view convertRect:keyboardBounds toView:nil]; [self.inputProjectView mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(self.view).offset(-CGRectGetHeight(keyboardBounds)); &#125;]; //设置动画 [UIView beginAnimations:nil context:NULL]; [UIView setAnimationBeginsFromCurrentState:YES]; [UIView setAnimationDuration:[duration doubleValue]]; [UIView setAnimationCurve:[curve intValue]]; [self.inputProjectView layoutIfNeeded]; [UIView commitAnimations];&#125;- (void)keyboardWillHide:(NSNotification *)notification &#123; if([self.inputProjectView inputText].length &gt; 0) &#123; [self.inputProjectView resetText]; &#125; CGRect keyboardBounds; [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] getValue:&amp;keyboardBounds]; NSNumber *duration = [notification.userInfo objectForKey:UIKeyboardAnimationDurationUserInfoKey]; NSNumber *curve = [notification.userInfo objectForKey:UIKeyboardAnimationCurveUserInfoKey]; keyboardBounds = [self.view convertRect:keyboardBounds toView:nil]; [self.inputProjectView mas_updateConstraints:^(MASConstraintMaker *make) &#123; if (@available(iOS 11.0, *)) &#123; make.bottom.equalTo(self.view).offset(self.view.safeAreaInsets.bottom+88); &#125; else &#123; make.bottom.equalTo(self.view).offset(88); &#125; make.height.mas_equalTo(88); &#125;]; //设置动画 [UIView beginAnimations:nil context:NULL]; [UIView setAnimationBeginsFromCurrentState:YES]; [UIView setAnimationDuration:[duration doubleValue]]; [UIView setAnimationCurve:[curve intValue]]; [self.inputProjectView layoutIfNeeded]; [UIView commitAnimations];&#125;切换输入法时，输入框被键盘遮住问题在修复此问题后，自测时发现，输入法由简体拼音切换为表情符号时，输入框会被键盘挡住，在代码中打断点发现UIKeyboardWillShowNotification和UIKeyboardWillChangeFrameNotification通知均未被触发，同时对比微信发现，切换输入法时，同时开启了自动校正功能，所以参考添加如下代码：1_textView.internalTextView.autocorrectionType = UITextAutocorrectionTypeYes;解决切换输入法时，输入框被键盘遮住的问题。总结除了上述Table View Cell移动的操作，在项目中还处理了创建事务和事务详情相关的业务。在整个过程中，比较棘手的还是Table View Cell的移动，在开发过程中，有时数据的移动和Table View Cell的移动未对应上，造成Table View Cell布局错乱，排查了很久。在项目开发过程中，还是需要仔细去分析需求。文章所对应的Demo请点这里]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI 长按移动 滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS深拷贝和浅拷贝]]></title>
    <url>%2F2017%2F12%2F14%2FiOS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在工作中，有时会涉及到深拷贝和浅拷贝的内容，发现有些地方理解的不够透彻，所以在网上搜集资料总结一下，主要分四个方面来介绍下iOS中深拷贝和浅拷贝：对象的拷贝；集合的拷贝；如何对集合进行深拷贝？总结对象的拷贝对对象进行拷贝，通过调用copy或mutableCopy方法来实现：调用 copy方法返回的对象为不可变对象,需要实现NSCopying协议 ；调用mutableCopy方法返回的对象为可变对象，需要实现NSMutableCopying协议 ；上图是苹果文档中关于对象拷贝的实例图，从图中可知：浅拷贝：object A和object B及其属性使用同样的内存地址，简单说明的话，可以认为是指针复制；深拷贝：object A和object B及其属性使用不同的内存地址，简单说明的话，可以认为是内容复制。下面通过分析NSString、NSMutableString、和自定义对象DBTestModel，调用copy和mutableCopy之后，分析其返回的对象及此对象的属性的内存地址来判断其行为是深拷贝还是浅拷贝。NSString通过打印的信息可知：对象string调用copy方法后返回的对象copySting，其所对应的内存地址和对象string一致，即为指针复制；对象string调用mutableCopy方法后返回的对象mutaCopySting，其所对应的内存地址和对象string不一致，即为指内容复制；NSMutableString通过打印的信息可知：对象mutaString调用copy方法后返回的对象copyMutaString，其所对应的内存地址和对象mutaString不一致，即为内容复制；对象mutaString调用mutableCopy方法后返回的对象mutaCopyMutaString，其所对应的内存地址和对象mutaString不一致，即为指内容复制；DBTestModel下面为自定义的对象’DBTestModel’:123456789101112131415#import &lt;Foundation/Foundation.h&gt;#import &lt;Mantle/Mantle.h&gt;@interface DBTestModel : MTLModel@property (nonatomic, copy) NSString *text;@property (nonatomic, strong) NSArray *sourceArray;@property (nonatomic, strong) NSMutableArray *mutableArray;- (instancetype)initWithText:(NSString *)text sourceArray:(NSArray *)sourceArray mutableArray:(NSMutableArray *)mutableArray;@end定义了三个属性，text、sourceArray、mutableArray。1234567891011121314151617181920212223242526272829303132- (void)testCustomObject &#123; NSMutableArray *mutableArray = [NSMutableArray array]; DBTestModel *model = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray]; DBTestModel *copyModel = [model copy]; DBTestModel *mutaCopyModel = [model mutableCopy]; NSLog(@"DBTestModel memory address"); NSLog(@"original :%p", model); NSLog(@"copy :%p", copyModel); NSLog(@"mutableCopy:%p", mutaCopyModel); NSLog(@"\n"); NSLog(@"text memory address"); NSLog(@"original :%p", model.text); NSLog(@"copy :%p", copyModel.text); NSLog(@"mutableCopy:%p", mutaCopyModel.text); NSLog(@"\n"); NSLog(@"sourceArray memory address"); NSLog(@"original :%p", model.sourceArray); NSLog(@"copy :%p", copyModel.sourceArray); NSLog(@"mutableCopy:%p", mutaCopyModel.sourceArray); NSLog(@"\n"); NSLog(@"mutableArray memory address"); NSLog(@"original :%p", model.mutableArray); NSLog(@"copy :%p", copyModel.mutableArray); NSLog(@"mutableCopy:%p", mutaCopyModel.mutableArray); NSLog(@"\n"); &#125;打印结果如下：分析其打印数据可知：除DBTestModel实例对象中的属性text和sourceArray调用copy后，没有产生一个新的对象，为指针复制，其余均为内容复制。集合的拷贝不可变集合NSArray123456789101112131415161718192021222324252627282930- (void)testCollectiveCopy &#123; NSMutableArray *mutableArray1 = [NSMutableArray array]; DBTestModel *model1 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray1]; NSMutableArray *mutableArray2 = [NSMutableArray array]; DBTestModel *model2 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray2]; NSMutableArray *mutableArray3 = [NSMutableArray array]; DBTestModel *model3 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray3]; NSArray *array = @[model1,model2,model3]; NSArray *copyArray = [array copy]; NSMutableArray *mutaCopyArray = [array mutableCopy]; NSLog(@"\nNSArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", array,copyArray,mutaCopyArray); DBTestModel *firstCopyModel = [copyArray firstObject]; DBTestModel *firstMutableCopyModel = [mutaCopyArray firstObject]; NSLog(@"\nDBTestModel memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1,firstCopyModel,firstMutableCopyModel); NSLog(@"\nDBTestModel sourceArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1.sourceArray,firstCopyModel.sourceArray,firstMutableCopyModel.sourceArray); &#125;打印结果如下：分析其打印数据可知：除NSArray实例对象调用mutableCopy方法为内容复制外，其余的均为指针拷贝。可变集合NSMutableArray测试代码如下：1234567891011121314151617181920212223242526272829303132- (void)testCollectiveMutacopy &#123; NSMutableArray *mutableArray1 = [NSMutableArray array]; DBTestModel *model1 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray1]; NSMutableArray *mutableArray2 = [NSMutableArray array]; DBTestModel *model2 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray2]; NSMutableArray *mutableArray3 = [NSMutableArray array]; DBTestModel *model3 = [[DBTestModel alloc] initWithText:@"text" sourceArray:@[@"test1",@"test2"] mutableArray:mutableArray3]; NSArray *array1 = @[model1,model2,model3]; NSMutableArray *mutaArray = [NSMutableArray arrayWithArray:array1]; NSMutableArray *copyMutaArray = [mutaArray copy]; NSMutableArray *mutaCopyMutaArray= [mutaArray mutableCopy]; NSLog(@"\nNSMutableArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", mutaArray,copyMutaArray,mutaCopyMutaArray); DBTestModel *firstCopyModel = [copyMutaArray firstObject]; DBTestModel *firstMutableCopyModel = [mutaCopyMutaArray firstObject]; NSLog(@"\nDBTestModel memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1,firstCopyModel,firstMutableCopyModel); NSLog(@"\nDBTestModel sourceArray memory address\noriginal :%p\ncopy :%p\nmutableCopy:%p\n", model1.sourceArray,firstCopyModel.sourceArray,firstMutableCopyModel.sourceArray);&#125;测试结果如下：分析其打印数据可知：除NSMutableArray实例对象调用copy和mutableCopy方法为内容复制外，数组内容的元素均为指针拷贝。结合上述测试代码得出的测试数据，得出如下的表格：从上图可以看出，NSArray或NSMutableArray对象调用copy或mutableCopy时，得到的集合中的元素均为指针拷贝，如果想要实现集合对象的深拷贝，应该怎么办呢？如何对集合进行深拷贝？集合的单层深复制 (one-level-deep copy)可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如1NSArray *copyArray = [[NSArray alloc] initWithArray:array copyItems:YES];如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。同时集合里的对象需遵循 NSCopying 协议，否则会崩溃。得到的结果如下：从打印结果可以看出，拷贝后和拷贝前的数组中的DBTestModel对象的sourceArray的内存地址是相同的，这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。A true deep copy使用归档来实现:NSArray *copyArray = [NSKeyedUnarchiver unarchiveObjectWithData: [NSKeyedArchiver archivedDataWithRootObject:array]]; ####小结在项目中遇到需要需要对对象进行拷贝时，需要理解以下两点：1、对系统自带的不可变对象进行copy时，为指针复制；2、对集合类对象进行copy或mutableCopy时，集合类的元素均为指针复制；3、如只需对集合进行单层深拷贝，可以使用initWithArray:copyItems:类似的方法，将第二个参数设为YES来实现，如需实现集合的完全复制，可以使用归解档来实现；4、第三方库Mantle中的MTLModel类有实现NSCoding和NSCopying协议，自定义的类继承MTLModel类即可实现NSCoding和NSCopying协议。参考链接Object copyingCopying Collections]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MBProgressHUD 源码分析]]></title>
    <url>%2F2017%2F11%2F08%2FMBProgressHUD%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在项目中经常会使用MBProgressHUD来实现弹窗提醒，所有来分析下MBProgressHUD这个三方库的代码。所分析的源码版本号为1.0.0。这篇总结主要分三个部分来介绍分析这个框架：代码结构方法调用流程图方法内部实现代码结构类图核心API属性12345678910111213141516171819/* * 用来推迟HUD的显示，避免HUD显示时间过短，出现一闪而逝的情况，默认值为0。 */@property (assign, nonatomic) NSTimeInterval graceTime;/** * HUD最短显示时间，单位为s，默认值为0。 */@property (assign, nonatomic) NSTimeInterval minShowTime;/** * HUD隐藏时，将其从父视图上移除 。默认值为NO */@property (assign, nonatomic) BOOL removeFromSuperViewOnHide; /** * HUD显示类型，默认为 MBProgressHUDModeIndeterminate. */@property (assign, nonatomic) MBProgressHUDMode mode;类方法1234567891011121314/** * 创建HUD,添加到提供的视图上并显示 */+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;/** * 找到最上层的HUD,并隐藏。 */+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;/** * 在传入的View上找到最上层的HUD并隐藏此HUD */+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;实例方法1234567891011121314/** * 构造函数，用来初始化HUD */- (instancetype)initWithView:(UIView *)view;/** * 显示HUD */- (void)showAnimated:(BOOL)animated;/** * 隐藏HUD */- (void)hideAnimated:(BOOL)animated;方法调用流程图从MBProgressHUD提供的主要接口可以看出，主要有显示HUD和隐藏HUD这两个功能，一步步追溯，得出的方法调用流程图如下：方法内部实现方法的内部实现主要从两个方面来分析，显示HUD和隐藏HUD。显示HUD首先是MBProgressHUD的构造方法123456789+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated &#123; //初始化MBProgressHUD MBProgressHUD *hud = [[self alloc] initWithView:view]; hud.removeFromSuperViewOnHide = YES; [view addSubview:hud]; [hud showAnimated:animated]; [[UINavigationBar appearance] setBarTintColor:nil]; return hud;&#125;首先进入- (id)initWithView:(UIView *)view方法，再进入- (instancetype)initWithFrame:(CGRect)frame方法，最后调用- (void)commonInit方法，进行属性的初始化和添加子视图。123456789101112131415161718192021222324- (void)commonInit &#123; // Set default values for properties _animationType = MBProgressHUDAnimationFade; _mode = MBProgressHUDModeIndeterminate; _margin = 20.0f; _opacity = 1.f; _defaultMotionEffectsEnabled = YES; // Default color, depending on the current iOS version BOOL isLegacy = kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_7_0; _contentColor = isLegacy ? [UIColor whiteColor] : [UIColor colorWithWhite:0.f alpha:0.7f]; // Transparent background self.opaque = NO; self.backgroundColor = [UIColor clearColor]; // Make it invisible for now self.alpha = 0.0f; self.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; self.layer.allowsGroupOpacity = NO; //添加子视图 [self setupViews]; //更新指示器 [self updateIndicators]; [self registerForNotifications];&#125;添加子视图都是常见的方式，让视图跟随陀螺仪运动，这个之前没有接触过，后续需要了解下。123456789101112131415161718192021222324252627- (void)updateBezelMotionEffects &#123;#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV MBBackgroundView *bezelView = self.bezelView; if (![bezelView respondsToSelector:@selector(addMotionEffect:)]) return; if (self.defaultMotionEffectsEnabled) &#123; CGFloat effectOffset = 10.f; UIInterpolatingMotionEffect *effectX = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; effectX.maximumRelativeValue = @(effectOffset); effectX.minimumRelativeValue = @(-effectOffset); UIInterpolatingMotionEffect *effectY = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis]; effectY.maximumRelativeValue = @(effectOffset); effectY.minimumRelativeValue = @(-effectOffset); UIMotionEffectGroup *group = [[UIMotionEffectGroup alloc] init]; group.motionEffects = @[effectX, effectY]; [bezelView addMotionEffect:group]; &#125; else &#123; NSArray *effects = [bezelView motionEffects]; for (UIMotionEffect *effect in effects) &#123; [bezelView removeMotionEffect:effect]; &#125; &#125;#endif&#125;再主要看下更新指示器的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- (void)updateIndicators &#123; UIView *indicator = self.indicator; BOOL isActivityIndicator = [indicator isKindOfClass:[UIActivityIndicatorView class]]; BOOL isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView class]]; MBProgressHUDMode mode = self.mode; //菊花动画 if (mode == MBProgressHUDModeIndeterminate) &#123; if (!isActivityIndicator) &#123; // Update to indeterminate indicator [indicator removeFromSuperview]; indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge]; [(UIActivityIndicatorView *)indicator startAnimating]; [self.bezelView addSubview:indicator]; &#125; &#125; //水平进度条动画 else if (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123; // Update to bar determinate indicator [indicator removeFromSuperview]; indicator = [[MBBarProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; //圆形进度动画 else if (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123; if (!isRoundIndicator) &#123; // Update to determinante indicator [indicator removeFromSuperview]; indicator = [[MBRoundProgressView alloc] init]; [self.bezelView addSubview:indicator]; &#125; //环形动画 if (mode == MBProgressHUDModeAnnularDeterminate) &#123; [(MBRoundProgressView *)indicator setAnnular:YES]; &#125; &#125; //自定义动画 else if (mode == MBProgressHUDModeCustomView &amp;&amp; self.customView != indicator) &#123; // Update custom view indicator [indicator removeFromSuperview]; indicator = self.customView; [self.bezelView addSubview:indicator]; &#125; //只显示文本 else if (mode == MBProgressHUDModeText) &#123; [indicator removeFromSuperview]; indicator = nil; &#125; indicator.translatesAutoresizingMaskIntoConstraints = NO; self.indicator = indicator; if ([indicator respondsToSelector:@selector(setProgress:)]) &#123; [(id)indicator setValue:@(self.progress) forKey:@"progress"]; &#125; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal]; [indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical]; [self updateViewsForColor:self.contentColor]; [self setNeedsUpdateConstraints];&#125;在这个方法中，主要是根据显示的模式，将不同的indicator视图赋值给indicator属性。更新完指示器后，就是开始将视图显示在界面上。调用的是- (void)showAnimated:(BOOL)animated方法。1234567891011121314151617181920212223- (void)showAnimated:(BOOL)animated &#123; //保证当前线程是主线程 MBMainThreadAssert(); [self.minShowTimer invalidate]; self.useAnimation = animated; self.finished = NO; // 如果设置了宽限时间，则推迟HUD的显示 if (self.graceTime &gt; 0.0) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:self.graceTime target:self selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO]; //默认把你的Timer以NSDefaultRunLoopMode添加到MainRunLoop上，而当当前视图在滚动时，当前的MainRunLoop是处于UITrackingRunLoopMode的模式下，在这个模式下，是不会处理NSDefaultRunLoopMode的消息，要想在scrollView滚动的同时Timer也执行的话，我们需要将Timer以NSRunLoopCommonModes的模式注册到当前RunLoop中. [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.graceTimer = timer; &#125; // ... otherwise show the HUD immediately else &#123; [self showUsingAnimation:self.useAnimation]; &#125;&#125;在- (void)showAnimated:(BOOL)animated方法中，主要做的是判断是否设置了推迟显示HUD的时间，如果设置了，就推迟设置的时间再显示。最后，执行- (void)showUsingAnimation:(BOOL)animated方法。123456789101112131415161718192021222324252627- (void)showUsingAnimation:(BOOL)animated &#123; // Cancel any previous animations [self.bezelView.layer removeAllAnimations]; [self.backgroundView.layer removeAllAnimations]; // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; //记录当前显示的时间，在HUD隐藏时，比较HUD显示到HUD隐藏之间的间隔与最小显示时间， //如果小于，继续显示，直到显示时间等于最小显示时间，再隐藏HUD self.showStarted = [NSDate date]; self.alpha = 1.f; // Needed in case we hide and re-show with the same NSProgress object attached. //好像是通过这个去刷新进度，这个需要再查下。 [self setNSProgressDisplayLinkEnabled:YES]; if (animated) &#123; [self animateIn:YES withType:self.animationType completion:NULL]; &#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" self.bezelView.alpha = self.opacity;#pragma clang diagnostic pop self.backgroundView.alpha = 1.f; &#125;&#125;最后执行- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion方法，这个方法显示和隐藏均会调用。12345678910111213141516171819202122232425262728293031323334353637383940414243//这个方法主要对self.bezelView视图进行动画- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion &#123; // Automatically determine the correct zoom animation type if (type == MBProgressHUDAnimationZoom) &#123; type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut; &#125; CGAffineTransform small = CGAffineTransformMakeScale(0.5f, 0.5f); CGAffineTransform large = CGAffineTransformMakeScale(1.5f, 1.5f); // Set starting state UIView *bezelView = self.bezelView; if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123; bezelView.transform = small; &#125; else if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123; bezelView.transform = large; &#125; // 使用动画 dispatch_block_t animations = ^&#123; if (animatingIn) &#123; bezelView.transform = CGAffineTransformIdentity; &#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123; bezelView.transform = large; &#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123; bezelView.transform = small; &#125;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wdeprecated-declarations" bezelView.alpha = animatingIn ? self.opacity : 0.f;#pragma clang diagnostic pop self.backgroundView.alpha = animatingIn ? 1.f : 0.f; &#125;; // Spring animations are nicer, but only available on iOS 7+#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123; [UIView animateWithDuration:0.3 delay:0. usingSpringWithDamping:1.f initialSpringVelocity:0.f options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion]; return; &#125;#endif [UIView animateWithDuration:0.3 delay:0. options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];&#125;从代码可以看出，这里只是对指示器的父视图做了放大缩小的动画。隐藏HUD1234567891011+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated &#123; //获取当前显示的hud,如果存在，当前隐藏时，将其从父视图移除 MBProgressHUD *hud = [self HUDForView:view]; if (hud != nil) &#123; hud.removeFromSuperViewOnHide = YES; [hud hideAnimated:animated]; return YES; &#125; return NO;&#125;在这个方法的执行过程中，调用- (void)hideAnimated:(BOOL)animated方法。12345678910111213141516171819 - (void)hideAnimated:(BOOL)animated &#123; MBMainThreadAssert(); [self.graceTimer invalidate]; self.useAnimation = animated; self.finished = YES; // 如果设置了最小显示时间，计算HUD显示时长， // 如果HUD显示时长小于最小显示时间，延迟显示 if (self.minShowTime &gt; 0.0 &amp;&amp; self.showStarted) &#123; NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:self.showStarted]; if (interv &lt; self.minShowTime) &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:(self.minShowTime - interv) target:self selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; self.minShowTimer = timer; return; &#125; &#125; // ... otherwise hide the HUD immediately [self hideUsingAnimation:self.useAnimation];&#125;- (void)hideAnimated:(BOOL)animated方法中，主要做的是判断是否需要推迟隐藏HUD，最后调用- (void)hideUsingAnimation:(BOOL)animated方法，12345678910111213141516- (void)hideUsingAnimation:(BOOL)animated &#123; //判断是否需要动画效果，如无，则直接隐藏 if (animated &amp;&amp; self.showStarted) &#123; self.showStarted = nil; //跟显示HUD差不多，只是指示器父视图没有做放大缩小的动画 [self animateIn:NO withType:self.animationType completion:^(BOOL finished) &#123; [self done]; &#125;]; &#125; else &#123; self.showStarted = nil; self.bezelView.alpha = 0.f; self.backgroundView.alpha = 1.f; [self done]; &#125;&#125;最后，调用- (void)done方法。这个方法主要负责属性的释放和隐藏完成回调的处理。- (void)done { // Cancel any scheduled hideDelayed: calls [self.hideDelayTimer invalidate]; //指示进度的显示问题，后续还需再补充 [self setNSProgressDisplayLinkEnabled:NO]; if (self.hasFinished) { self.alpha = 0.0f; if (self.removeFromSuperViewOnHide) { [self removeFromSuperview]; } } MBProgressHUDCompletionBlock completionBlock = self.completionBlock; if (completionBlock) { completionBlock(); } id&lt;MBProgressHUDDelegate&gt; delegate = self.delegate; if ([delegate respondsToSelector:@selector(hudWasHidden:)]) { [delegate performSelector:@selector(hudWasHidden:) withObject:self]; } } 总结从代码来看，MBProgressHUD这个三方库有几个地方值借鉴：graceTime和minShowTime，在开发的时候会出现显示HUD后，存在缓存或者网速较好时，HUD显示到HUD隐藏的时间较短，界面出现闪动的情况，这时，就可以通过设置graceTime和minShowTime来处理，达到更好的用户体验。 这个在封装弹窗控件时，可以参考。]]></content>
      <categories>
        <category>三方开源库</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS布局与Masnory使用实践]]></title>
    <url>%2F2017%2F11%2F06%2FiOS%E5%B8%83%E5%B1%80%E4%B8%8EMasnory%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言UI布局对于iOS开发者来说并不陌生，在iOS6之前，大家都是通过UI控件的Frame属性和Autoresizing Mask来进行UI布局的（简称为手动布局）。AutoLayout则是苹果公司在iOS6推出的一种基于约束的，描述性的布局系统（简称为自动布局），这里主要从四个方面来阐述iOS布局及实践。手动布局和自动布局AutoLayout原理AutoLayout的性能Masnory的使用首先对手动布局和自动布局做一个简单的介绍：手动布局和自动布局手动布局：指的是通过直接修改视图的frame属性的方式对界面进行布局。对于IOS的app开发者来说，不会像Android开发者一样为很多的屏幕尺寸来做界面适配，因此手动调整 frame的方式来布局也能工作良好。但是还是会有一些问题，如设备发生旋转、适配ipad等，并且保证视图原来之间的相对关系，则以上的方法都是无法解决的。如果要做这些适配，在AutoLayout未出来之前需要编写大量的代码，并且花费大量的调试适配时间。自动布局：指的是使用AutoLayout的方式对界面进行布局。AutoLayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 AutoLayout对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，AutoLayout 带来的 CPU 消耗会呈指数级上升。 如果对界面流畅度要求较高（如微博界面），可以通过提前计算好布局，在需要时一次性调整好对应属性 ，或者使用 ComponentKit、AsyncDisplayKit 等框架来处理界面布局。下面，我们来分析下 AutoLayout的原理。AutoLayout的原理这里通过使用Masonry来进行布局，从而来分析AutoLayout的原理，先简要了解下Masonry。Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 iOS 和 Max OS X。Masnory支持的常用属性如下：1234567891011@property (nonatomic, strong, readonly) MASConstraint *left; //左侧@property (nonatomic, strong, readonly) MASConstraint *top; //上侧@property (nonatomic, strong, readonly) MASConstraint *right; //右侧@property (nonatomic, strong, readonly) MASConstraint *bottom; //下侧@property (nonatomic, strong, readonly) MASConstraint *leading; //首部@property (nonatomic, strong, readonly) MASConstraint *trailing; //首部@property (nonatomic, strong, readonly) MASConstraint *width; //宽@property (nonatomic, strong, readonly) MASConstraint *height; //高@property (nonatomic, strong, readonly) MASConstraint *centerX; //横向中点@property (nonatomic, strong, readonly) MASConstraint *centerY; //纵向中点@property (nonatomic, strong, readonly) MASConstraint *baseline; //文本基线其中leading与left，trailing与right 在正常情况下是等价的，但是当一些布局是从右至左时(比如阿拉伯语) 则会对调。同时，在Masonry中能够添加AutoLayout约束有三个函数：123- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;//只负责新增约束` AutoLayout`不能同时存在两条针对于同一对象的约束,否则会报错- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;//针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;//则会清除之前的所有约束 仅保留最新的约束我们在代码中，经常会使用到equalTo和mas_equalTo，那它们的区别是什么呢？从代码中找到他们的定义如下：123#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__)))...#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))可以看到 mas_equalTo只是对其参数进行了一个BOX操作(装箱) ，所支持的类型，除了NSNumber支持的那些数值类型之外，还支持CGPoint，CGSize和UIEdgeInsets类型。下面，我们通过一个例子，一步步来看下界面是怎么布局的，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor blackColor]; UIView *v1 = [[UIView alloc] init]; v1.backgroundColor = [UIColor orangeColor]; [v1 showPlaceHolder]; UIView *v2 = [[UIView alloc] init]; v2.backgroundColor = [UIColor orangeColor]; [v2 showPlaceHolder]; UIView *v3 = [[UIView alloc] init]; v3.backgroundColor = [UIColor orangeColor]; [v3 showPlaceHolder]; [self.view addSubview:v1]; [self.view addSubview:v2]; [self.view addSubview:v3]; [v1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(100); make.leading.mas_equalTo(100); make.width.mas_equalTo(70); make.height.mas_equalTo(65); &#125;]; [v2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(v1.mas_top); make.leading.mas_equalTo(v1.mas_trailing).offset(20); make.width.equalTo(v1.mas_width); make.height.equalTo(v1.mas_height); &#125;]; [v3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(v1.mas_bottom).offset(20); make.leading.equalTo(v1.mas_leading); make.trailing.equalTo(v2.mas_trailing); make.height.equalTo(v1.mas_height); &#125;];&#125;界面运行结果如下图：下面，我们将界面中的左上角的视图视为视图1，右上角的视图视为视图2，底部视图视为视图3，使用x1、y1、m1、n1来标识视图1的left、top、width和height，以此类推。通过以上举例抽象出自动布局数学公式：将以上等式变形为：此时，以上方程组，大家肯定很熟悉了，也就是《线性代数》中的线性方程组，现在将以上线性方程组抽象为：上图表示“等式”方程组，那么是否还可以继续抽象？也就是说上述方程组能否完全表示未知元素之间与已知元素之间的关系，显然还不全面，因为还有（&lt;,&gt;,&lt;=,&gt;=）不等关系，因此将“=”等号抽象为关系”R”,在数学上关系R也就包括了“=”,”&lt;”,”&gt;”,”&lt;=”,”&gt;=”等关系。上述线程方程组变形为：（实质上，AutoLayout中所有的约束确实都是用数学关系式y R ax + b描述）现在已经将自动布局一步步抽象为数学公式，那么对视图的布局其实就是对线性方程组的求解。线性方程组解的情况有三种，实质上也对应着自动布局对视图的三种布局方案:唯一解：所有方程中的未知数能够解出唯一解。 充分约束：给一个视图添加的约束必须是充分的，才能正确布局一个视图；多个解：未知数不能求解出准确的唯一解，即未知数可能存在多个或者无限个解满足线性方程组。 欠约束：给视图所添加的约束不能够充分的表达视图的准确位置，在这种情况下自动布局会随意给视图一个布局方案，也就是自动布局中视图不能够正确布局或者视图丢失的情况。无解：不存在满足线性方程组的解。 冲突约束：给视图添加的约束表达视图布局出现了冲突，比如同时满足同一个视图宽度即为100又为200，这是不可能存在的。此时程序会出现崩溃。通过以上描述，将AutoLayout系统的作用描述如图所示：AutoLayout的性能从AutoLayout的原理，我们可以得出布局系统最后仍然需要通过frame来进行布局，相比原有的布局系统加入了从约束计算 出frame 的过程,那么这个过程对性能是否会影响呢？你可以在 这里 找到这次对 Layout 性能测量使用的代码。代码分别使用Auto Layout、嵌套视图层级中使用 Auto Layout和frame对 N 个视图进行布局，测算其运行时间。对视图数量在 1~35 之间布局时间进行测量，结果如下：对视图数量在 10~500 之间布局时间进行测量，结果如下：从上述的测试数据可以看出，使用frame、AutoLayout和嵌套视图层级中使用 Auto Layout进行布局、对应的视图数量分别为50个、6个和12个，所需要的时间就会在 16.67 ms左右。,而想要让 iOS 应用的视图保持 60 FPS 的刷新频率，我们必须在 1/60 = 16.67 ms 之内完成包括布局、绘制以及渲染等操作。综上所述，虽然说 Auto Layout 为开发者在多尺寸布局上提供了遍历，而且支持跨越视图层级的约束，但是由于其实现原理导致其时间复杂度为多项式时间，其性能损耗是仅使用 frame 的十几倍，所以在处理庞大的 UI界面时表现差强人意。Masnory的使用下面，我们通过4个实例，来了解下Masnory的使用。######case 1: 并排显示两个label，宽度由内容决定。父视图宽度不够时，优先显示右边label的内容。在默认情况下，我们没有设置各个布局的优先级，那么他就会优先显示左边的label，左边的完全显示后剩余的空间都是右边的label，如果整个空间宽度都不够左边的label的话，那么右边的label就没有显示的机会了。如果我们现在的需求是优先显示右边的label，左边的label内容超出的省略，这时就需要我们调整约束的优先级了。UIView中关于Content Hugging 和Content Compression Resistance的方法有：12345- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);那么这两个东西到底是什么呢？可以这样形象的理解一下：contentHugging: 抱住使其在“内容大小”的基础上不能继续变大，这个属性的优先级越高，就要越“抱紧”视图里面的内容。也就是视图的大小不会随着父视图的扩大而扩大。contentCompression: 撑住使其在在其“内容大小”的基础上不能继续变小,这个属性的优先级越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的视图时，Content Compression Resistance优先级越高的，显示的内容越完整。这两个属性分别可以设置水平方向和垂直方向上的，而且一个默认优先级是250， 一个默认优先级是750. 因为这两个很有可能与其他Constraint冲突，所以优先级较低。1234static const UILayoutPriority UILayoutPriorityRequired NS_AVAILABLE_IOS(6_0) = 1000; // A required constraint. Do not exceed this.static const UILayoutPriority UILayoutPriorityDefaultHigh NS_AVAILABLE_IOS(6_0) = 750; // This is the priority level with which a button resists compressing its content.static const UILayoutPriority UILayoutPriorityDefaultLow NS_AVAILABLE_IOS(6_0) = 250; // This is the priority level at which a button hugs its contents horizontally.static const UILayoutPriority UILayoutPriorityFittingSizeLevel NS_AVAILABLE_IOS(6_0) = 50;1234567891011121314151617181920212223242526- (void)layoutPageSubViews &#123; [self.leftLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.contentView1.mas_top).with.offset(5); make.left.equalTo(self.contentView1.mas_left).with.offset(2); make.height.equalTo(@40); &#125;]; [self.rightLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.leftLabel.mas_right).with.offset(2); make.top.equalTo(self.contentView1.mas_top).with.offset(5); make.right.lessThanOrEqualTo(self.contentView1.mas_right).with.offset(-2); make.height.equalTo(@40); &#125;]; [self.leftLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; [self.leftLabel setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal]; [self.rightLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; [self.rightLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];&#125;######case 2: 四个ImageView整体居中，可以任意显示、隐藏。下面的四个Switch控件分别控制上面对应位置的图片是否显示。分析:首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个容器View里面，然后让这个容器View在整个页面中居中即可。这样就不用控制每个图片的居中效果了。然后就是显示与隐藏。在这里我直接控制图片ImageView的宽度，宽度为0的时候不就“隐藏”了吗。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142- (void)layoutPageSubViews &#123; [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(IMAGE_SIZE); make.centerX.equalTo(self.view.mas_centerX); make.top.equalTo(self.view.mas_top).offset(200); &#125;]; //分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象 //每个View的左边约束和左边的View的右边相等 __block UIView *lastView = nil; __block MASConstraint *widthConstraint = nil; NSUInteger arrayCount = self.imageViews.count; [self.imageViews enumerateObjectsUsingBlock:^(UIView *view, NSUInteger idx, BOOL *stop) &#123; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(lastView ? lastView.mas_right : view.superview.mas_left); make.centerY.equalTo(view.superview.mas_centerY); if (idx == arrayCount - 1) &#123; make.right.equalTo(view.superview.mas_right); &#125; widthConstraint = make.width.mas_equalTo(IMAGE_SIZE); make.height.mas_equalTo(IMAGE_SIZE); [self.widthConstraints addObject:widthConstraint]; lastView = view; &#125;]; &#125;];&#125;#pragma mark - event response//点击switch按钮，如果打开，对应视图的宽约束设置为32，否则，设置为0- (IBAction)showOrHideImage:(UISwitch *)sender &#123; NSUInteger index = (NSUInteger) sender.tag; MASConstraint *width = self.widthConstraints[index]; if (sender.on) &#123; width.mas_equalTo(IMAGE_SIZE); &#125; else &#123; width.mas_equalTo(0); &#125;&#125;#####case 3: 子视图的宽度始终是父视图的四分之三（或者任意百分比）12345678910 //宽度为父view的宽度的四分之三 [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //上下左贴边 make.left.equalTo(_containerView.mas_left); make.top.equalTo(_containerView.mas_top); make.bottom.equalTo(_containerView.mas_bottom); //宽度为父view的宽度的一半 make.width.equalTo(_containerView.mas_width).multipliedBy(0.75); &#125;];#####case 4 给同一个属性添加多重约束，实现复杂关系 - (void)layoutPageSubviews { [self.greenLabel mas_makeConstraints:^(MASConstraintMaker *make) { make.centerY.equalTo(self.containerView); make.right.lessThanOrEqualTo(self.containerView); make.left.greaterThanOrEqualTo(self.containerView.mas_right).multipliedBy((CGFloat)(1.0f / 3.0f)); for (UILabel *label in self.leftLabels) { make.left.greaterThanOrEqualTo(label.mas_right).offset(8); } }]; [self.greenLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]; } 总结通过上述分析，我们可以发现：AutoLayout的原理就是对线性方程组或者不等式的求解，最终使用frame来绘制视图；使用AutoLayout进行布局时， 由于其实现原理导致其时间复杂度为多项式时间，其性能损耗是仅使用 frame 的十几倍，所以在处理庞大的 UI界面时表现差强人意。]]></content>
      <categories>
        <category>iOS 自动布局</category>
      </categories>
      <tags>
        <tag>自动布局 AutoLayout Masnory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS二维码识别/二维码生成]]></title>
    <url>%2F2017%2F11%2F03%2Fqr-droid%2F</url>
    <content type="text"><![CDATA[前言之前做过一个关于二维码的组件，已发布，现总结下。开发的APP所需支持的最低版本为8.0，最初的方案为扫描使用苹果自带的API实现扫一扫的功能、使用ZXing识别从相册或别人转发的二维码图片。但发现ZXing识别从相册中来的图片性能很差，很多图片识别不了，且耗时较长，遂使用ZBar来实现识别从相册或别人转发的二维码图片。这个组件重要实现了三个功能，扫一扫识别二维码图片、长按图片识别二维码图片和生成二维码图片。首先来看下扫一扫识别二维码图片的代码实现：功能实现扫一扫识别二维码图片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485- (void)initCapture &#123; AVCaptureDevice* inputDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; [inputDevice lockForConfiguration:nil]; if ([inputDevice hasTorch])&#123; inputDevice.torchMode = AVCaptureTorchModeAuto; &#125; AVCaptureFocusMode foucusMode = AVCaptureFocusModeContinuousAutoFocus; if ([inputDevice isFocusModeSupported:foucusMode]) &#123; inputDevice.focusMode = foucusMode; &#125; [inputDevice unlockForConfiguration]; AVCaptureDeviceInput *captureInput = [AVCaptureDeviceInput deviceInputWithDevice:inputDevice error:nil]; if (!captureInput) &#123; //支持的最低版本为iOS8 UIAlertController *alterVC = [UIAlertController alertControllerWithTitle:MUIQRCodeLocalizedString(@"ScanViewController_system_tip") message:MUIQRCodeLocalizedString(@"ScanViewController_camera_permission") preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:MUIQRCodeLocalizedString(@"ScanViewController_yes") style:UIAlertActionStyleDefault handler:nil]; [alterVC addAction:confirmAction]; [self presentViewController:alterVC animated:YES completion:nil]; [self.activityView stopAnimating]; [self onVideoStart:nil]; return; &#125; AVCaptureMetadataOutput *captureOutput = [[AVCaptureMetadataOutput alloc] init]; [captureOutput setMetadataObjectsDelegate:self queue:_queue]; self.captureOutput = captureOutput; self.captureSession = [[AVCaptureSession alloc] init]; [self.captureSession addInput:captureInput]; [self.captureSession addOutput:captureOutput]; CGFloat w = 1920.f; CGFloat h = 1080.f; if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset1920x1080]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset1920x1080; &#125; else if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset1280x720; w = 1280.f; h = 720.f; &#125; else if ([self.captureSession canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123; self.captureSession.sessionPreset = AVCaptureSessionPreset640x480; w = 960.f; h = 540.f; &#125; captureOutput.metadataObjectTypes = [captureOutput availableMetadataObjectTypes]; CGRect bounds = [[UIScreen mainScreen] bounds]; if (!self.prevLayer) &#123; self.prevLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession]; &#125; self.prevLayer.frame = bounds; self.prevLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; [self.view.layer insertSublayer:self.prevLayer atIndex:0]; //下面代码主要用来设置扫描的聚焦范围，计算rectOfInterest CGFloat p1 = bounds.size.height/bounds.size.width; CGFloat p2 = w/h; CGRect cropRect = CGRectMake(CGRectGetMinX(_cropRect) - kSNReaderScanExpandWidth, CGRectGetMinY(_cropRect) - kSNReaderScanExpandHeight, CGRectGetWidth(_cropRect) + 2*kSNReaderScanExpandWidth, CGRectGetHeight(_cropRect) + 2*kSNReaderScanExpandHeight); // CGRect cropRect = _cropRect; if (fabs(p1 - p2) &lt; 0.00001) &#123; captureOutput.rectOfInterest = CGRectMake(cropRect.origin.y /bounds.size.height, cropRect.origin.x/bounds.size.width, cropRect.size.height/bounds.size.height, cropRect.size.width/bounds.size.width); &#125; else if (p1 &lt; p2) &#123; //实际图像被截取一段高 CGFloat fixHeight = bounds.size.width * w / h; CGFloat fixPadding = (fixHeight - bounds.size.height)/2; captureOutput.rectOfInterest = CGRectMake((cropRect.origin.y + fixPadding)/fixHeight, cropRect.origin.x/bounds.size.width, cropRect.size.height/fixHeight, cropRect.size.width/bounds.size.width); &#125; else &#123; CGFloat fixWidth = bounds.size.height * h / w; CGFloat fixPadding = (fixWidth - bounds.size.width)/2; captureOutput.rectOfInterest = CGRectMake(cropRect.origin.y/bounds.size.height, (cropRect.origin.x + fixPadding)/fixWidth, cropRect.size.height/bounds.size.height, cropRect.size.width/fixWidth); &#125;&#125;识别二维码图片识别二维码图片的功能，最初的方案是使用三方库ZXing来实现，因为ZXing有人在维护，但ZXing识别相册中的二维码图片或本地的图片时，有些图片根本就识别不出来，且耗时较长，所以改为使用ZBar。在网上找到一篇文章再见ZXing 使用系统原生代码处理QRCode,实测发现使用系统原生代码来识别二维码图片时，在，iphone4s，系统为iOS9的手机发现传回来的数组为空。代码如下：12345678910111213141516171819- (NSString *)decodeQRImageWith:(UIImage*)aImage &#123; NSString *qrResult = nil; //iOS8及以上可以使用系统自带的识别二维码图片接口，但此api有问题，在一些机型上detector为nil。 if (iOS8_OR_LATER) &#123; CIContext *context = [CIContext contextWithOptions:nil]; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; CIImage *image = [CIImage imageWithCGImage:aImage.CGImage]; NSArray *features = [detector featuresInImage:image]; CIQRCodeFeature *feature = [features firstObject]; qrResult = feature.messageString; &#125; else &#123; ZBarReaderController* read = [ZBarReaderController new]; CGImageRef cgImageRef = aImage.CGImage; ZBarSymbol* symbol = nil; for(symbol in [read scanImage:cgImageRef]) break; qrResult = symbol.data ; return qrResult; &#125; &#125;无图无真相：detector的值为nil，也就是说1CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;];CIDetector的初始化方法无效。推测是苹果API的问题。生成二维码图片在iOS8及以上版本使用苹果的API生成二维码图片，代码如下：123456789101112131415161718192021222324252627282930313233- (UIImage *)encodeQRImageWithContent:(NSString *)content size:(CGSize)size &#123; UIImage *codeImage = nil; if (iOS8_OR_LATER) &#123; NSData *stringData = [content dataUsingEncoding: NSUTF8StringEncoding]; //生成 CIFilter *qrFilter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [qrFilter setValue:stringData forKey:@"inputMessage"]; [qrFilter setValue:@"M" forKey:@"inputCorrectionLevel"]; UIColor *onColor = [UIColor blackColor]; UIColor *offColor = [UIColor whiteColor]; //上色 CIFilter *colorFilter = [CIFilter filterWithName:@"CIFalseColor" keysAndValues: @"inputImage",qrFilter.outputImage, @"inputColor0",[CIColor colorWithCGColor:onColor.CGColor], @"inputColor1",[CIColor colorWithCGColor:offColor.CGColor], nil]; CIImage *qrImage = colorFilter.outputImage; CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent]; UIGraphicsBeginImageContext(size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationNone); CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage); codeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGImageRelease(cgImage); &#125; else &#123; codeImage = [QRCodeGenerator qrImageForString:content imageSize:size.width]; &#125; return codeImage; &#125;iOS8以下使用libqrencode库来生成二维码图片。代码完善2015年12月11日QA测试发现，服务端生成的二维码，使用ZBar识别不出来，但将这张图片保存到相册，然后发送就可以识别出来。最初的想法是要服务端修改生成的二维码，但安卓能够识别出来，此路不通，那只有看ZBar的源码了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (id &lt;NSFastEnumeration&gt;) scanImage: (CGImageRef) image &#123; timer_start; int nsyms = [self scanImage: image withScaling: 0]; //没有识别出来，判断CGImageRef对象的宽和高是否大于640，大于或等于的话进行缩放再进行扫描 if(!nsyms &amp;&amp; CGImageGetWidth(image) &gt;= 640 &amp;&amp; CGImageGetHeight(image) &gt;= 640) // make one more attempt for close up, grainy images nsyms = [self scanImage: image withScaling: .5]; NSMutableArray *syms = nil; if(nsyms) &#123; // quality/type filtering int max_quality = MIN_QUALITY; for(ZBarSymbol *sym in scanner.results) &#123; zbar_symbol_type_t type = sym.type; int quality; if(type == ZBAR_QRCODE) quality = INT_MAX; else quality = sym.quality; if(quality &lt; max_quality) &#123; zlog(@" type=%d quality=%d &lt; %d\n", type, quality, max_quality); continue; &#125; if(max_quality &lt; quality) &#123; max_quality = quality; if(syms) [syms removeAllObjects]; &#125; zlog(@" type=%d quality=%d\n", type, quality); if(!syms) syms = [NSMutableArray arrayWithCapacity: 1]; [syms addObject: sym]; &#125; &#125; zlog(@"read %d filtered symbols in %gs total\n", (!syms) ? 0 : [syms count], timer_elapsed(t_start, timer_now())); return(syms); &#125; if(max_quality &lt; quality) &#123; max_quality = quality; if(syms) [syms removeAllObjects]; &#125; zlog(@" type=%d quality=%d\n", type, quality); if(!syms) syms = [NSMutableArray arrayWithCapacity: 1]; [syms addObject: sym]; &#125; &#125; zlog(@"read %d filtered symbols in %gs total\n", (!syms) ? 0 : [syms count], timer_elapsed(t_start, timer_now())); return(syms);&#125;在这里就产生了一个解决有些二维码图片识别不出来的解决思路：将传过来的UIImage的宽和高设置为640，识别不出来再进行缩放识别。修改UIImage的代码如下：123456789101112-(UIImage *)TransformtoSize:(CGSize)Newsize &#123; // 创建一个bitmap的context UIGraphicsBeginImageContext(Newsize); // 绘制改变大小的图片 [self drawInRect:CGRectMake(0, 0, Newsize.width, Newsize.height)]; // 从当前context中创建一个改变大小后的图片 UIImage *TransformedImg=UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); // 返回新的改变大小后的图片 return TransformedImg;&#125;这样类似于将ZXing中的tryHard设置为YES。识别不出来的二维码图片就可以识别了。2016年5月20日遗留的bug: 点击进入扫一扫界面，退出，再进入，这样重复5次左右，扫一扫之前的界面的会出现卡顿。原因：多次进入扫一扫界面，再退出，因此界面未被系统回收，captureSession对象一直在运行，会造成内存泄露，引起上一个界面卡顿。解决方案：在视图将要消失的时候，确保captureSession对象停止运行。123456- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; if ([self.captureSession isRunning]) &#123; [self.captureSession stopRunning]; &#125;&#125;2018年4月28日识别二维码图片优化近期通过bugly收集卡顿问题发现，二维码组件在识别二维码图片时，会出现卡顿问题。为优化识别速度，采用了三种方案，并分别进行测试，并对测试数据进行分析，最终挑选出最优的方案。任务A：使用系统提供的CoreImage的CIDetector接口去识别二维码图片，返回对应的字符串；任务B：使用zbar中的方法去识别二维码图片，返回对应的字符串。1234567891011121314151617181920212223242526//任务A+ (NSString *)useSystemMethodDecodeImage:(UIImage *)image &#123; NSString *resultString = nil; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:nil options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; if (detector) &#123; CIImage *ciImage = [CIImage imageWithCGImage:image.CGImage]; NSArray *features = [detector featuresInImage:ciImage]; CIQRCodeFeature *feature = [features firstObject]; resultString = feature.messageString; &#125; return resultString;&#125;//任务B+ (NSString *)useZbarMethodDecodeImage:(UIImage *)image &#123; UIImage *decodeImage = image; if (decodeImage.size.width &lt; 641) &#123; decodeImage = [decodeImage TransformtoSize:CGSizeMake(640, 640)]; &#125; QRCodeZBarReaderController* read = [QRCodeZBarReaderController new]; CGImageRef cgImageRef = decodeImage.CGImage; QRCodeZBarSymbol *symbol = nil; for(symbol in [read scanImage:cgImageRef]) break; return symbol.data;&#125;方案A：先执行任务A，如果获取到的字符串为空，再执行任务B。123456789101112131415161718192021222324+ (NSString *)planOneDecodeWithImage:(UIImage *)image index:(NSInteger)index&#123; NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); NSString *detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; CFAbsoluteTime detectorCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",detectorCostTime *1000.0]]; NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime zbarStartTime = CFAbsoluteTimeGetCurrent(); NSString *zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime zbarCostTime = (CFAbsoluteTimeGetCurrent() - zbarStartTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",zbarCostTime *1000.0]]; CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy];&#125;方案B：同时执行任务A和任务B，两者均执行完后，返回识别的结果；123456789101112131415161718192021222324252627282930313233343536+ (NSString *)planTwoDecodeWithImage:(UIImage *)image index:(NSInteger)index &#123; __block NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; __block NSString *detectorString = nil; __block NSString *zbarSymbolString = nil; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",costTime *1000.0]]; &#125;); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",costTime *1000.0]]; &#125;); dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^&#123; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy];&#125;方案C：同时执行任务A和任务B1、任务A先执行完且识别成功，返回识别结果；2、任务B先执行完且识别成功，返回识别结果；3、任务A和任务B均识别失败，两者均执行完后，返回识别的结果。+ (NSString *)planThreeDecodeWithImage:(UIImage *)image index:(NSInteger)index { __block NSMutableString *costTimeInfo = [NSMutableString stringWithFormat:@"%ld\r\n",index]; __block NSString *detectorString = nil; __block NSString *zbarSymbolString = nil; __block BOOL isNeedSendSignal = YES; CFAbsoluteTime startTime = CFAbsoluteTimeGetCurrent(); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{ detectorString = [MUIQRCodeDecoder useSystemMethodDecodeImage:image]; //NSAssert(detectorString.length &gt; 0, @"detector fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"detector : %f ms\r\n",costTime *1000.0]]; if (detectorString.length &gt; 0 &amp;&amp; isNeedSendSignal) { isNeedSendSignal = NO; dispatch_semaphore_signal(semaphore); } }); dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{ zbarSymbolString = [MUIQRCodeDecoder useZbarMethodDecodeImage:image]; //NSAssert(zbarSymbolString.length &gt; 0, @"zbar fail!"); CFAbsoluteTime costTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"zbar : %f ms\r\n",costTime *1000.0]]; if (zbarSymbolString.length &gt; 0 &amp;&amp; isNeedSendSignal) { isNeedSendSignal = NO; dispatch_semaphore_signal(semaphore); } }); dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{ if (isNeedSendSignal) { dispatch_semaphore_signal(semaphore); } }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); CFAbsoluteTime totalCostTime = (CFAbsoluteTimeGetCurrent() - startTime); [costTimeInfo appendString:[NSString stringWithFormat:@"total cost : %f ms\r\n",totalCostTime *1000.0]]; [costTimeInfo appendString:[NSString stringWithFormat:@"detectorString : %@ ms\r\n",detectorString]]; [costTimeInfo appendString:[NSString stringWithFormat:@"zbarSymbolString : %@ ms\r\n",zbarSymbolString]]; return [costTimeInfo copy]; } 测试数据如下所示:(取了前10张图片）分析测试数据发现：1、在测试第一张二维码图片时，总耗时均较大，如果第一次识别使用的是系统方法，耗时超过500ms，这也是为什么会出现卡顿的原因；2、使用系统方法去识别二维码图片时，如果不是第一次去识别，耗时较小，在65ms以内；3、使用zbar的方法去识别二维码图片，耗时均值在200ms以内；4、在方案C中，如果第一次使用系统方法，耗时为226ms。总结得出，从优化卡顿问题的角度出发，使用方案C最优，同时发现，如果使用系统方法能识别出二维码图片，在初始化之后（也就是第二次使用），耗时最短。同时因为在实际的使用场景中，图片是一张一张识别的，识别过程有一个间隔时间，如果已经使用系统方法识别过二维码图片，那下次识别就能达到最优。所以使用方案C的话，最差情况均值在200ms左右，最好的情况和方案A中第二次使用系统方法耗时基本一致。综合考虑，使用方案C。小结在实际的项目开发过程中，设想的情况和实际情况会存在偏差，需要自己时刻使用性能调优工具，根据数据去进行优化，而不能想当然的认为某种方式是最优的。源码和demo请点这里参考的文章链接如下再见ZXing 使用系统原生代码处理QRCodeIOS二维码扫描,你需要注意的两件事Zbar算法流程介绍]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>二维码 图片识别</tag>
      </tags>
  </entry>
</search>
