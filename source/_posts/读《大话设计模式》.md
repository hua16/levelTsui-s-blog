title: 读《大话设计模式》
tags:
  - 设计模式 设计模式六大原则
categories:
  - 设计模式 开发
author: leveltsui
date: 2018-07-13 20:42:00
---
## 前言 
对设计模式的理解，不够透彻，有时去找资料，总是零零散散，不成系统，故将《大话设计模式》中的干货整理下，方便需要使用时参阅。

## 设计模式六大原则

### 单一职责原则

定义：就一个类而言，应该仅有一个引起它变化的原因。通俗的说，即一个类只负责一项职责。 
问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。
解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。
优点：
- 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
- 提高类的可读性，提高系统的可维护性；
- 降低需求变更引起的风险。

### 里氏替换原则

定义：子类型必须能够替换掉它们的父类型。
问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。
解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

### 依赖倒转原则

定义：A.高层模块不应该依赖底层模块。两者都应该依赖抽象。
     B.抽象不应该依赖细节。细节应该依赖抽象。
     通俗理解：针对接口编程，不要针对实现编程。
问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。
最佳实践：
- 低层模块尽量都要有抽象类或接口，或者抽象类或接口两者都具备。
- 变量的声明类型尽量是抽象类或接口。
- 使用继承时遵循里氏替换原则。

### 接口隔离原则

定义：一个类对另一个类的依赖，应该建立在最小的接口上。
问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。
![未遵循接口隔离原则的设计](./images/design_pattern_un_isolate_port.png)
![遵循接口隔离原则的设计](./images/design_pattern_solate_port.png)
最佳实践：
- 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度；
- 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系；
- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情；
- 适度使用，接口设计的过大或过小都不好。

### 迪米特法则

定义：又叫最少知道原则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
     一个对象应该对其他对象保持最少的了解。
问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
解决方案：尽量降低类与类之间的耦合。可以通过第三者来进行通信。
### 开放-封闭原则
定义：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。
问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

### 六大原则总结
用抽象构建框架，用实现扩展细节。
- 单一职责原则告诉我们实现类要职责单一；
- 里氏替换原则告诉我们不要破坏继承体系；
- 依赖倒置原则告诉我们要面向接口编程；
- 接口隔离原则告诉我们在设计接口的时候要精简单一；
- 迪米特法则告诉我们要降低耦合。
- 而开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。

[设计模式六大原则](http://www.uml.org.cn/sjms/201211023.asp#4)  

## UML基础知识
![UML类图图示](./images/design_pattern_uml.png)
### 类与类之间的关系
- 泛化：是一种继承关系，表示一般与特殊的关系，存在于父类与子类、父接口与子接口之间，表示子类如何特
   化父类的所有特征和行为，比如动物和鸟之间的关系；
- 实现：一种类与接口的关系，表示类对接口所有特征和行为的实现，比如大雁与接口飞翔的关系；
- 组合：是一种强的‘拥有’关系，体现了严格的整体和部分的关系，部分和整体的生命周期一样，比如鸟与翅膀的关系；
- 聚合：是一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，比如雁群和大雁的关系；
- 关联：描述了类与类之间的结构化关系，具有方向、名字、角色和多重性等信息，是一种拥有的关
系，它使一个类知道另一个类的属性和方法，比如企鹅与气候的关系，人与住址的关系；
- 依赖：是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，表示一个事
物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。
  1、将一个类的对象作为另一个类中方法的参数
  2、在一个类的方法中将另一个类的对象作为其局部变量
  3、在一个类的方法中调用另一个类的静态方法。

各种关系的强弱顺序：
泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖

## 常用的23中设计模式

### 创建型模式

#### 简单工厂模式

##### 模式动机

考虑一个简单的软件应用场景，一个计算器有不同的按钮（如+、-、*、÷）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以完成不同的功能，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。

##### 模式定义

简单工厂模式(Simple Factory Pattern)：它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

##### 模式结构

简单工厂模式包含如下角色：
- HCDCalcuteFactory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
- HCDCalculate：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- HCDCalculateAdd：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
![简单工厂模式类图](./images/design_simple-factory-class.png)

##### 时序图
![简单工厂模式时序图](./images/design_simple-factory-class-sequence.png)

##### 源码
```objc
//HCDCalculateProtocol.h
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

typedef NS_ENUM(NSInteger, HCDCalculateType) {
    HCDCalculateTypeAdd = 0,   //加
    HCDCalculateTypeMinus,     //减
    HCDCalculateTypeMultipy,   //乘
    HCDCalculateTypeDivide     //除
};

@protocol HCDCalculateProtocol <NSObject>

@optional
-(CGFloat)calculate;

@end
```

```objc
//HCDCalculate.h
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>
#import "HCDCalculateProtocol.h"

@interface HCDCalculate : NSObject <HCDCalculateProtocol>

@property(nonatomic, assign) CGFloat numberA;
@property(nonatomic, assign) CGFloat numberB;

@end
```

```objc
//HCDCalcuteFactory.h
#import <Foundation/Foundation.h>
#import "HCDCalculate.h"

@interface HCDCalcuteFactory : NSObject

+(HCDCalculate *)createCalcute:(NSString *)calculatetype;

@end

//HCDCalcuteFactory.m
#import "HCDCalcuteFactory.h"
#import "HCDCalculateAdd.h"
#import "HCDCalculateDivide.h"
#import "HCDCalculateMinus.h"
#import "HCDCalcuteMultiply.h"

@implementation HCDCalcuteFactory

+(HCDCalculate *)createCalcute:(NSString *)calculatetype {
    
    NSArray *calculateArray = @[@"+",@"-",@"*",@"/"];
    
    if (![calculateArray containsObject:calculatetype]) {
        return nil;
    }
    HCDCalculateType calType = [calculateArray indexOfObject:calculatetype];
    
    
    switch (calType) {
        case HCDCalculateTypeAdd:
            return [[HCDCalculateAdd alloc]init];
            break;
        case HCDCalculateTypeMinus:
            return [[HCDCalculateMinus alloc]init];
            break;
        case HCDCalculateTypeMultipy:
            return [[HCDCalcuteMultiply alloc]init];
        case HCDCalculateTypeDivide:
            return [[HCDCalculateDivide alloc]init];
    }
}
@end
```

```objc
//HCDCalculateAdd.m
#import "HCDCalculateAdd.h"

@implementation HCDCalculateAdd

-(CGFloat)calculate{
    return self.numberA + self.numberB;
}
@end

//HCDCalculateMinus.m
#import "HCDCalculateMinus.h"

@implementation HCDCalculateMinus

-(CGFloat)calculate{
    return self.numberA - self.numberB;
}

@end

//HCDCalcuteMultiply
#import "HCDCalcuteMultiply.h"

@implementation HCDCalcuteMultiply

-(CGFloat)calculate{
    return self.numberA * self.numberB;
}
@end

//HCDCalculateDivide.m
#import "HCDCalculateDivide.h"

@implementation HCDCalculateDivide

- (CGFloat)calculate{
    if (self.numberB == 0) {
        NSLog(@"dividend is can not be zero!");
        return 0;
    }
    return self.numberA/self.numberB;
}

@end
```

#### 工厂方法模式

##### 模式动机
现在对该系统进行修改，不再设计一个运算工厂类来统一负责所有产品的创建，而是将具体运算的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的运算工厂类，再定义具体的工厂类来生成加法运算、减法运算、乘法运算等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新运算的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。
##### 模式定义
工厂方法模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
##### 模式结构
工厂方法模式包含如下角色：
- HCDCalculate：抽象产品
- HCDCalculateAdd：具体产品
- HCDfactory：抽象工厂
- HCDfactoryAdd：具体工厂
![工厂方法模式类图](./images/design-factory-method-class.png)
##### 时序图
![工厂方法模式时序图](./images/design-factory-method-sequence.png)
##### 源码
```objc
//HCDfactory.h

#import <Foundation/Foundation.h>
#import "HCDCalculate.h"

@interface HCDfactory : NSObject

-(HCDCalculate *)createFactory;

@end

//HCDfactory.m
#import "HCDfactory.h"

@implementation HCDfactory

-(HCDCalculate *)createFactory {
    return nil;
}

@end

//HCDfactoryAdd.m
@implementation HCDfactoryAdd

-(HCDCalculate *)createFactory {
    return [[HCDCalculateAdd alloc]init];
}
@end

//HCDfactoryMinus.m
@implementation HCDfactoryMinus

-(HCDCalculate *)createFactory {
    return [[HCDCalculateMinus alloc]init];
}
@end

//HCDfactoryMultiply.m
@implementation HCDfactoryMultiply

-(HCDCalculate *)createFactory {
    return [[HCDCalcuteMultiply alloc]init];
}
@end

//HCDfactoryDivide.m
@implementation HCDfactoryDivide

-(HCDCalculate *)createFactory {
    return [[HCDCalculateDivide alloc]init];
}
@end
```
```objc
//HCDCalculate.h
@interface HCDCalculate : NSObject <HCDCalculateProtocol>

@property(nonatomic, assign) CGFloat numberA;
@property(nonatomic, assign) CGFloat numberB;

@end

//HCDCalculateAdd.m
@implementation HCDCalculateAdd

-(CGFloat)calculate{
    return self.numberA + self.numberB;
}
@end

//HCDCalculateMinus.m
@implementation HCDCalculateMinus

-(CGFloat)calculate{
    return self.numberA - self.numberB;
}

@end

//HCDCalcuteMultiply.m
@implementation HCDCalcuteMultiply

-(CGFloat)calculate{
    return self.numberA * self.numberB;
}
@end

//HCDCalculateDivide.m
@implementation HCDCalculateDivide

- (CGFloat)calculate{
    if (self.numberB == 0) {
        NSLog(@"dividend is can not be zero!");
        return 0;
    }
    return self.numberA/self.numberB;
}

@end

//HCDCalculateProtocol.h
typedef NS_ENUM(NSInteger, HCDCalculateType) {
    HCDCalculateTypeAdd = 0,   //加
    HCDCalculateTypeMinus,     //减
    HCDCalculateTypeMultipy,   //乘
    HCDCalculateTypeDivide     //除
};

@protocol HCDCalculateProtocol <NSObject>

@optional
-(CGFloat)calculate;

@end
```
```objc
//使用示例
    HCDfactory *addFactory = [[HCDfactoryAdd alloc]init];
    HCDCalculate *addCalculate = [addFactory createFactory];
    addCalculate.numberA = 10;
    addCalculate.numberB = 15;
    NSLog(@"结果是%f\n",[addCalculate calculate]);
    
    HCDfactory *minusFactory = [[HCDfactoryMinus alloc]init];
    HCDCalculate *minusCalculate = [minusFactory createFactory];
    minusCalculate.numberA = 10;
    minusCalculate.numberB = 15;
    NSLog(@"结果是%f\n",[minusCalculate calculate]);
    
    HCDfactory *multiplyFactory = [[HCDfactoryMultiply alloc]init];
    HCDCalculate *multiplyCalculate = [multiplyFactory createFactory];
    multiplyCalculate.numberA = 10;
    multiplyCalculate.numberB = 15;
    NSLog(@"结果是%f\n",[multiplyCalculate calculate]);
    
    HCDfactory *divideFactory = [[HCDfactoryDivide alloc]init];
    HCDCalculate *divideCalculate = [divideFactory createFactory];
    divideCalculate.numberA = 10;
    divideCalculate.numberB = 15;
    NSLog(@"结果是%f\n",[divideCalculate calculate]);
    
```

#### 抽象工厂模式

##### 模式动机
- 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂-方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。
- 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。
##### 模式定义
抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。属于对象创建型模式。
##### 模式结构
抽象工厂模式包含如下角色：
- HCDFactory：抽象工厂
- HCDSqlserverFactory：具体工厂
- HCDDepartment：抽象产品
- HCDSqlserverDepartment：具体产品
![抽象工厂模式类图](./images/design-abstract-factory-class.png)
##### 时序图
![抽象工厂模式时序图](./images/design-abstract-factory-sequence.png)
##### 源码

```objc
//HCDFactory.h
@protocol HCDFactory <NSObject>

-(id<HCDUser>)createUser;
-(id<HCDDepartment>)createDepartment;

@end

//HCDSqlserverFactory.m
@implementation HCDSqlserverFactory

-(id<HCDUser>)createUser{
    return [[HCDSqlserverUser alloc]init];
}

-(id<HCDDepartment>)createDepartment{
    return [[HCDSqlserverDepartment alloc]init];
}

@end

//HCDAccessFactory.m
-(id<HCDUser>)createUser{
    return [[HCDAccessUser alloc]init];
}

-(id<HCDDepartment>)createDepartment{
    return [[HCDAccessDepartment alloc]init];
}

@end 
```

```objc
//HCDDepartment.h
@protocol HCDDepartment <NSObject>

-(void)insertDepartment:(SQLDepartment *)department;

-(SQLDepartment *)getDepartment;

@end

//HCDSqlserverDepartment.m
@implementation HCDSqlserverDepartment

-(SQLDepartment *)getDepartment{
    NSLog(@"新建一个Sqlserver的SQLDepartment对象");
    return [[SQLDepartment alloc]init];
}

-(void)insertDepartment:(SQLDepartment *)department{
    NSLog(@"插入一个Sqlserver的SQLDepartment对象");
}

@end

//HCDAccessDepartment.m
@implementation HCDAccessDepartment

-(SQLDepartment *)getDepartment{
    NSLog(@"新建一个Access的SQLDepartment对象");
    return [[SQLDepartment alloc]init];
}

-(void)insertDepartment:(SQLDepartment *)department{
    NSLog(@"插入一个Access的SQLDepartment对象");
}

@end
```

```objc
//HCDUser.h
@protocol HCDUser <NSObject>

-(void)insertUser:(SQLUser *)user;

-(SQLUser *)getUser;

@end

//HCDSqlserverUser.m
@implementation HCDSqlserverUser

-(SQLUser *)getUser{
    NSLog(@"新建一个Sqlserver的SQLUser对象");
    return [[SQLUser alloc]init];
}

-(void)insertUser:(SQLUser *)user{
     NSLog(@"插入一个Sqlserver的SQLUser对象");
}

@end

//HCDAccessUser.m
@implementation HCDAccessUser

-(SQLUser *)getUser{
    NSLog(@"新建一个Access的SQLUser对象");
    return [[SQLUser alloc]init];
}

-(void)insertUser:(SQLUser *)user{
    NSLog(@"插入一个Access的SQLUser对象");
}

@end
```
```objc
//使用示例
    id<HCDFactory> factory0 = [[HCDSqlserverFactory alloc]init];
    id<HCDDepartment> department0 = [factory0 createDepartment];
    [department0 insertDepartment:[[SQLDepartment alloc]init]];
    [department0 getDepartment];
    
    id<HCDUser> user0 = [factory0 createUser];
    [user0 insertUser:[[SQLUser alloc] init]];
    [user0 getUser];
    
    id<HCDFactory> factory1 = [[HCDAccessFactory alloc]init];
    id<HCDDepartment> department1 = [factory1 createDepartment];
    [department1 insertDepartment:[[SQLDepartment alloc]init]];
    [department1 getDepartment];
    
    id<HCDUser> user1 = [factory1 createUser];
    [user1 insertUser:[[SQLUser alloc] init]];
    [user1 getUser];
```


#### 建造者模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 单例模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码


### 结构式模式

#### 适配器模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 桥接模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 装饰模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 外观模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 享元模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 代理模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码




### 行为型模式

#### 命令模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 中介者模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 观察者模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 状态模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 策略模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码
```objc
```
```objc
```

#### 原型模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 模板方法模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码


#### 组合模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 迭代器模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码 

#### 职责链模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 解释器模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码

#### 访问者模式

##### 模式动机
##### 模式定义
##### 模式结构
##### 时序图
##### 源码


## 小结
在实际的项目开发过程中，设想的情况和实际情况会存在偏差，需要自己时刻使用性能调优工具，根据数据去进行优化，而不能想当然的认为某种方式是最优的。
源码和demo请点[这里](https://github.com/leverTsui/QRCodeDemo.git)
参考的文章链接如下
[再见ZXing 使用系统原生代码处理QRCode](http://adad184.com/2015/09/30/goodbye-zxing/)
[IOS二维码扫描,你需要注意的两件事](http://blog.cnbluebox.com/blog/2014/08/26/ioser-wei-ma-sao-miao/)
[[Zbar算法流程介绍](http://blog.csdn.net/u013738531/article/details/54574262)](http://blog.csdn.net/u013738531/article/details/54574262)